Here is the **Software Development Checklist**. The purpose of the list is to create a minimum set of tools and rules that are applicable to each quality software project, from one-man army open-source to enterprise giant.

Got the ideas? Create pull request!

# ğŸ‘©â€ğŸ’» Code

* [ ] Use **version control** for project files ([Recommendations at Slant](https://www.slant.co/topics/370/~best-version-control-systems)).
* [ ] **Monitor and log** your application ([Stackify article](https://stackify.com/monitor-software-deployment/) Â· [Best practices at Logmatic](https://logmatic.io/blog/beyond-application-monitoring-discover-logging-best-practices/)).
* [ ] Setup **continuous integration (CI) server** ([Awesome List](https://github.com/ciandcd/awesome-ciandcd) Â· [Recommendations at Slant](https://www.slant.co/topics/799/~best-continuous-integration-tools)).

# ğŸ“ˆ Process

* [ ] Use **project management tracking system** (also known as *bug tracker* or *issue tracker*).
* [ ] Create a **backlog** for your items.
* [ ] Improve the process by making **small iterative changes** in your process (*kaizen*).

# ğŸ“ƒ Documentation

* [ ] Setup **wiki-engined documentation**.
* [ ] Prepare **license info** and make it available for everyone in organisation.

# ğŸ“† Meetings

* [ ] Always send meeting information via **calendar software**.
* [ ] Include online **conference details** in event details (phone number and/or meeting link).
* [ ] Mark attendees as either **required or non-required**.

# ğŸ’¬ Team

* [ ] Use effective **communication tool** across organisation.
* [ ] Avoid **single point of failure** (with [`Bus.Factor == 1`](https://en.wikipedia.org/wiki/Bus_factor)).

# â“ What to consider?

Apart from the must-have, there are many wonderful nice-to-try ideas that may work with your project! If you're not familiar, you may research these.

* Consider **code reviews** ([Awesome List](https://github.com/joho/awesome-code-review) Â· [Software Engineering thread](https://softwareengineering.stackexchange.com/questions/255944/what-is-the-purpose-of-a-code-review)).
* Consider **pair programming**.
* Consider **[Semantic Versioning](https://semver.org/)**.
* Consider setup separate environments (e.g. **development**, **testing**, **staging** and **production**).
* Consider using **distributed version control**, such as Git or Mercurial.
* Consider **pull requests**, rather than pushing code to a repository.
* Consider using **policies for pull requests**, like build succesful, automated tests passing, changes reviewed.
* Consider using **Definition of Done** and **Definition of Ready**.
* Consider using **acceptance criteria** (also known as *exit criteria*) to describe stories. Use these to resolve all ambiguations.
* Consider using **template for bug ticket** (environment, version or commit ID, reproduction steps, expected behavior).
* Consider document **on-boarding process** on wiki with all the required tools, resources, hacks, etc.
